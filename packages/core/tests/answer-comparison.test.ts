import { describe, it, expect } from 'vitest';
import { checkAnswer, formatForDisplay, normalizeForComparison } from '../src/answer-comparison';

// Helper to generate permutations for validating comma-separated answers
function getPermutations<T>(array: T[]): T[][] {
  if (array.length === 0) return [[]];
  const firstEl = array[0];
  const rest = array.slice(1);
  const permsWithoutFirst = getPermutations(rest);
  const allPermutations: T[][] = [];
  permsWithoutFirst.forEach((perm) => {
    for (let i = 0; i <= perm.length; i++) {
      const permWithFirst = [...perm.slice(0, i), firstEl, ...perm.slice(i)];
      allPermutations.push(permWithFirst);
    }
  });
  return allPermutations;
}

describe('Answer Comparison and Text Processing', () => {
  describe('1. Normalization (`normalizeForComparison`)', () => {
    const testCases = [
      // Case and Whitespace
      { input: '  HeLlO  wOrLd  ', expected: 'helloworld' },
      { input: '\t  Test  \n', expected: 'test' },

      // Cyrillic —ë/–µ equivalence
      { input: '–ï—â—ë –æ–¥–∏–Ω —Ç—ë–º–Ω—ã–π –¥–µ–Ω—å', expected: '–µ—â–µ–æ–¥–∏–Ω—Ç–µ–º–Ω—ã–π–¥–µ–Ω—å' },
      { input: '—Ç—ë–º–Ω—ã–π', expected: '—Ç–µ–º–Ω—ã–π' },
      { input: '–¢–Å–ú–ù–´–ô', expected: '—Ç–µ–º–Ω—ã–π' },

      // Latin-to-Cyrillic homoglyphs (in Cyrillic context)
      { input: 'cop', expected: '—Å–æ—Ä' },
      { input: 'COP', expected: '—Å–æ—Ä' },

      // German Umlauts and √ü
      { input: 'M√ºller', expected: 'muller' },
      { input: 'Mueller', expected: 'muller' },
      { input: 'Sch√∂n', expected: 'schon' },
      { input: 'Schoen', expected: 'schon' },
      { input: 'Gr√º√üe', expected: 'grusse' },
      { input: 'Gruesse', expected: 'grusse' },
      { input: 'Stra√üe', expected: 'strasse' },
      { input: '√ºber', expected: 'uber' },
      { input: 'ueber', expected: 'uber' },

      // Spanish and other Latin diacritics
      { input: 'Jos√©', expected: 'jose' },
      { input: 'ni√±o', expected: 'nino' },
      { input: 'caf√©', expected: 'cafe' },
      { input: 'fa√ßade', expected: 'facade' },
      { input: 'coraz√≥n', expected: 'corazon' },
      { input: 'espa√±ol', expected: 'espanol' },

      // Mixed content
      { input: 'M√ºller caf√©', expected: 'mullercafe' },

      // Edge cases
      { input: '', expected: '' },
      { input: '   ', expected: '' },
    ];

    testCases.forEach(({ input, expected }) => {
      it(`should normalize "${input}" to "${expected}"`, () => {
        expect(normalizeForComparison(input)).toBe(expected);
      });
    });
  });

  describe('2. Display Formatting (`formatForDisplay`)', () => {
    const testCases = [
      // Basic pipe alternatives - show first
      { input: 'hello|hi|hey', expected: 'hello' },
      { input: '–ø—Ä–∏–≤–µ—Ç|–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π', expected: '–ø—Ä–∏–≤–µ—Ç' },

      // Preserve brackets, commas, and regular parentheses
      { input: 'word[s]', expected: 'word[s]' },
      { input: 'red, blue', expected: 'red, blue' },
      { input: 'word (context)', expected: 'word (context)' },

      // Parentheses with pipes - key feature from the review
      { input: '(a|b), (c|d)', expected: 'a, c' },
      { input: '(—Ç—Ä—É–¥–Ω—ã–π|—Å–ª–æ–∂–Ω—ã–π), (—Ç–≤—ë—Ä–¥—ã–π|–∂—ë—Å—Ç–∫–∏–π)', expected: '—Ç—Ä—É–¥–Ω—ã–π, —Ç–≤—ë—Ä–¥—ã–π' },
      { input: '(–º–µ–Ω—è—Ç—å|–∏–∑–º–µ–Ω—è—Ç—å), (–∏–∑–º–µ–Ω–µ–Ω–∏–µ|—Å–º–µ–Ω–∞)', expected: '–º–µ–Ω—è—Ç—å, –∏–∑–º–µ–Ω–µ–Ω–∏–µ' },
      { input: '(–º–∞—Ç—á|—Å–æ—Ä–µ–≤–Ω–æ–≤–∞–Ω–∏–µ), —Å–ø–∏—á–∫–∞, (–ø–æ–¥—Ö–æ–¥–∏—Ç—å|—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å)', expected: '–º–∞—Ç—á, —Å–ø–∏—á–∫–∞, –ø–æ–¥—Ö–æ–¥–∏—Ç—å' },
      { input: '(–∑–Ω–∞—á–∏—Ç—å|–æ–∑–Ω–∞—á–∞—Ç—å), –∏–º–µ—Ç—å –≤ –≤–∏–¥—É', expected: '–∑–Ω–∞—á–∏—Ç—å, –∏–º–µ—Ç—å –≤ –≤–∏–¥—É' },
      { input: '(–¥–≤–∏–≥–∞—Ç—å|–ø–µ—Ä–µ–º–µ—â–∞—Ç—å), –ø–µ—Ä–µ–µ–∑–∂–∞—Ç—å, –¥–≤–∏–∂–µ–Ω–∏–µ', expected: '–¥–≤–∏–≥–∞—Ç—å, –ø–µ—Ä–µ–µ–∑–∂–∞—Ç—å, –¥–≤–∏–∂–µ–Ω–∏–µ' },
      { input: '(–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å', expected: '–∑–∞–ø–∏—Å–∫–∞, –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å' },
      { input: '(a|b)', expected: 'a' },

      // Mixed content
      { input: '(a|b), word, [clarification], (x|y)', expected: 'a, word, [clarification], x' },

      // Parentheses without pipes should be preserved
      { input: 'word (context), another', expected: 'word (context), another' },
      { input: '(a|b), (context), (x|y|z)', expected: 'a, (context), x' },

      // Multiple parentheses groups in succession
      { input: '(a|b)(c|d)(e|f)', expected: 'ace' },

      // Whitespace handling
      { input: '  ( a | b ) ,  (c|d)  ', expected: 'a, c' },
      { input: '(option1 | option2 | option3)', expected: 'option1' },
      { input: '( space1 | space2 )', expected: 'space1' },
      { input: 'hello | hi | hey', expected: 'hello' },
      { input: 'hello\t|\thi', expected: 'hello' },
      { input: '(a  |  b), (c|d)', expected: 'a, c' },

      // Comma cleanup
      { input: ' , word, ', expected: 'word' },
      { input: ', , word, ,', expected: 'word' },

      // Edge cases
      { input: '()', expected: '' },
      { input: 'word, ()', expected: 'word' },
      { input: '(|a)', expected: 'a' },
      { input: '(a|)', expected: 'a' },
      { input: '((()))', expected: '' },

      // Pipes inside brackets are preserved
      { input: 'pipes[inside|brackets]', expected: 'pipes[inside|brackets]' },
      { input: 'prefix[opt1|opt2]suffix', expected: 'prefix[opt1|opt2]suffix' },

      // Documentation examples
      { input: '–±–∞–Ω–∫, —Å–∫–∞–º–µ–π–∫–∞', expected: '–±–∞–Ω–∫, —Å–∫–∞–º–µ–π–∫–∞' },
      { input: 'bonito|hermoso|lindo', expected: 'bonito' },
      { input: '–º–∏—Ä [–≥–∞—Ä–º–æ–Ω–∏—è]', expected: '–º–∏—Ä [–≥–∞—Ä–º–æ–Ω–∏—è]' },
      { input: '—ç—Ç–∞–∂ (–∑–¥–∞–Ω–∏—è)', expected: '—ç—Ç–∞–∂ (–∑–¥–∞–Ω–∏—è)' },
      { input: '–º–∞—à–∏–Ω–∞|–∞–≤—Ç–æ–º–æ–±–∏–ª—å', expected: '–º–∞—à–∏–Ω–∞' },

      // Malformed input gracefully handled
      { input: 'word[incomplete', expected: 'word[incomplete' },
      { input: 'incomplete]word', expected: 'incomplete]word' },
      { input: 'word(incomplete', expected: 'word(incomplete' },
      { input: 'incomplete)word', expected: 'incomplete)word' },
      { input: 'word||another', expected: 'word' },
      { input: '||word', expected: '' },
      { input: 'word||', expected: 'word' },
      { input: '|||', expected: '' },

      // Unicode and special characters
      { input: 'caf√©|na√Øve', expected: 'caf√©' },
      { input: 'üòÄ|üòÉ', expected: 'üòÄ' },
      { input: 'English|–†—É—Å—Å–∫–∏–π', expected: 'English' },
      { input: '(option1|–≤–∞—Ä–∏–∞–Ω—Ç2)', expected: 'option1' },
      { input: 'word\u00A0|other', expected: 'word' }, // Non-breaking space
    ];

    testCases.forEach(({ input, expected }) => {
      it(`should format "${input}" for display as "${expected}"`, () => {
        expect(formatForDisplay(input)).toBe(expected);
      });
    });
  });

  describe('3. Answer Checking (`checkAnswer`)', () => {
    // Define components to dynamically build complex test cases
    const components = {
      c1: {
        def: 'run|jog',
        valid: ['run', 'jog'],
        invalid: ['walk', 'sprint'],
      },
      c2: {
        def: 'fast|quick',
        valid: ['fast', 'quick'],
        invalid: ['slow', 'rapid'],
      },
      c3: {
        def: 'car[s]',
        valid: ['car', 'cars', 'car s'],
        invalid: ['s', 'vehicle'],
      },
      c4: {
        def: '–ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]',
        valid: ['–ø–∞—Ä–∫–æ–≤–∞—Ç—å', '–ø–∞—Ä–∫–æ–≤–∞—Ç—å—Å—è', '–ø–∞—Ä–∫–æ–≤–∞—Ç—å —Å—è'],
        invalid: ['—Å—è', '—Å—Ç–æ—è—Ç—å'],
      },
      c5: {
        def: '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]',
        valid: ['–º–∏—Ä', '–º–∏—Ä –≤—Å–µ–ª–µ–Ω–Ω–∞—è', '–º–∏—Ä–≤—Å–µ–ª–µ–Ω–Ω–∞—è'],
        invalid: ['–≤—Å–µ–ª–µ–Ω–Ω–∞—è', '–∫–æ—Å–º–æ—Å'],
      },
      c6: {
        def: 'test[ing]',
        valid: ['test', 'testing', 'test ing'],
        invalid: ['ing', 'exam'],
      },
    };

    describe('3.1 Single Group Validation', () => {
      // Test each component individually
      for (const key in components) {
        const { def, valid, invalid } = components[key as keyof typeof components];
        describe(`Component "${def}"`, () => {
          valid.forEach((answer) => {
            it(`should accept "${answer}"`, () => {
              expect(checkAnswer(answer, def)).toBe(true);
            });
          });
          invalid.forEach((answer) => {
            it(`should reject "${answer}"`, () => {
              expect(checkAnswer(answer, def)).toBe(false);
            });
          });
        });
      }

      // Additional single group tests
      const singleGroupTests = [
        { user: 'hello', correct: 'hello', expected: true },
        { user: 'Hello', correct: 'hello', expected: true },
        { user: 'hello', correct: 'world', expected: false },
        { user: 'hello', correct: 'hello|hi|hey', expected: true },
        { user: 'hi', correct: 'hello|hi|hey', expected: true },
        { user: 'greetings', correct: 'hello|hi|hey', expected: false },
        { user: 'good morning', correct: 'good [morning]', expected: true },
        { user: 'good', correct: 'good [morning]', expected: true },
        { user: 'morning', correct: 'good [morning]', expected: false },
      ];

      singleGroupTests.forEach(({ user, correct, expected }) => {
        it(`should return ${expected} for "${user}" vs "${correct}"`, () => {
          expect(checkAnswer(user, correct)).toBe(expected);
        });
      });
    });

    describe('3.2 Multi-Group (Comma) Validation', () => {
      const group1 = components.c1; // run|jog
      const group2 = components.c2; // fast|quick
      const group3 = components.c4; // –ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]
      const correctAnswer = `(${group1.def}), (${group2.def}), ${group3.def}`;

      // Generate all possible valid answer combinations
      const validAnswers: string[][] = [];
      for (const v1 of group1.valid) {
        for (const v2 of group2.valid) {
          for (const v3 of group3.valid) {
            validAnswers.push([v1, v2, v3]);
          }
        }
      }

      // Test a sample of permutations (not all to keep test time reasonable)
      validAnswers.slice(0, 3).forEach((answerTuple) => {
        getPermutations(answerTuple).forEach((perm) => {
          const userAnswer = perm.join(', ');
          it(`should accept correct combination: "${userAnswer}"`, () => {
            expect(checkAnswer(userAnswer, correctAnswer)).toBe(true);
          });
        });
      });

      // Test invalid combinations
      const invalidScenarios = [
        { answer: 'run, fast', reason: 'missing a part' },
        { answer: 'run', reason: 'missing parts' },
        { answer: 'run, fast, –ø–∞—Ä–∫–æ–≤–∞—Ç—å, extra', reason: 'too many parts' },
        { answer: 'run, slow, –ø–∞—Ä–∫–æ–≤–∞—Ç—å', reason: 'incorrect part' },
        { answer: 'walk, fast, –ø–∞—Ä–∫–æ–≤–∞—Ç—å', reason: 'incorrect part' },
      ];

      invalidScenarios.forEach(({ answer, reason }) => {
        it(`should reject "${answer}" (${reason})`, () => {
          expect(checkAnswer(answer, correctAnswer)).toBe(false);
        });
      });
    });

    describe('3.3 Normalization Integration', () => {
      const testCases = [
        // Cyrillic —ë/–µ equivalence
        { user: '—Ç—ë–º–Ω—ã–π', correct: '—Ç–µ–º–Ω—ã–π', expected: true },
        { user: '—Ç–µ–º–Ω—ã–π', correct: '—Ç—ë–º–Ω—ã–π', expected: true },
        { user: '–¢–Å–ú–ù–´–ô', correct: '—Ç–µ–º–Ω—ã–π', expected: true },
        { user: '—Ç—ë–º–Ω—ã–π', correct: '—Ç–µ–º–Ω—ã–π|—á—ë—Ä–Ω—ã–π', expected: true },
        { user: '—á—ë—Ä–Ω—ã–π', correct: '—Ç–µ–º–Ω—ã–π|—á–µ—Ä–Ω—ã–π', expected: true },
        { user: '—Ç—ë–º–Ω—ã–π, —á—ë—Ä–Ω—ã–π', correct: '—Ç–µ–º–Ω—ã–π, —á–µ—Ä–Ω—ã–π', expected: true },
        { user: '—á–µ—Ä–Ω—ã–π, —Ç—ë–º–Ω—ã–π', correct: '—Ç–µ–º–Ω—ã–π, —á—ë—Ä–Ω—ã–π', expected: true },

        // Latin/Cyrillic character mapping
        { user: 'cop', correct: '—Å–æ—Ä', expected: true },
        { user: '—Å–æ—Ä', correct: 'cop', expected: true },
        { user: 'COP', correct: '—Å–æ—Ä', expected: true },
        { user: 'cop', correct: '—Å–æ—Ä|–º—É—Å–æ—Ä', expected: true },
        { user: '–º—É—Å–æ—Ä', correct: 'cop|–º—É—Å–æ—Ä', expected: true },
        { user: 'cop, –º—É—Å–æ—Ä', correct: '—Å–æ—Ä, –º—É—Å–æ—Ä', expected: true },

        // Spanish accent normalization
        { user: 'cafe', correct: 'caf√©', expected: true },
        { user: 'caf√©', correct: 'cafe', expected: true },
        { user: 'nino', correct: 'ni√±o', expected: true },
        { user: 'ni√±o', correct: 'nino', expected: true },
        { user: 'corazon', correct: 'coraz√≥n', expected: true },
        { user: 'espanol', correct: 'espa√±ol', expected: true },
        { user: 'cafe', correct: 'caf√©|coffee', expected: true },
        { user: 'coffee', correct: 'caf√©|coffee', expected: true },
        { user: 'caf√©', correct: 'cafe|coffee', expected: true },
        { user: 'cafe, nino', correct: 'caf√©, ni√±o', expected: true },
        { user: 'caf√©, ni√±o', correct: 'cafe, nino', expected: true },
        { user: 'M√âXICO', correct: 'mexico', expected: true },
        { user: 'educaci√≥n', correct: 'EDUCACION', expected: true },

        // German umlaut normalization
        { user: 'mude', correct: 'm√ºde', expected: true },
        { user: 'm√ºde', correct: 'mude', expected: true },
        { user: 'uber', correct: '√ºber', expected: true },
        { user: '√ºber', correct: 'uber', expected: true },
        { user: 'schon', correct: 'sch√∂n', expected: true },
        { user: 'grosse', correct: 'gr√∂√üe', expected: true },
        { user: 'muede', correct: 'm√ºde', expected: true },
        { user: 'm√ºde', correct: 'muede', expected: true },
        { user: 'ueber', correct: '√ºber', expected: true },
        { user: '√ºber', correct: 'ueber', expected: true },
        { user: 'schoen', correct: 'sch√∂n', expected: true },
        { user: 'sch√∂n', correct: 'schoen', expected: true },
        { user: 'groesse', correct: 'gr√∂√üe', expected: true },
        { user: 'gr√∂√üe', correct: 'groesse', expected: true },
        { user: 'mude', correct: 'm√ºde|tired', expected: true },
        { user: 'tired', correct: 'm√ºde|tired', expected: true },
        { user: 'm√ºde', correct: 'mude|tired', expected: true },
        { user: 'mude, schon', correct: 'm√ºde, sch√∂n', expected: true },
        { user: 'm√ºde, sch√∂n', correct: 'mude, schon', expected: true },
        { user: 'strasse', correct: 'stra√üe', expected: true },
        { user: 'stra√üe', correct: 'strasse', expected: true },
        { user: 'weiss', correct: 'wei√ü', expected: true },
        { user: 'wei√ü', correct: 'weiss', expected: true },

        // Complex normalization with multiple features
        { user: 'M√ºde, caf√©, —Ç—ë–º–Ω—ã–π', correct: 'muede, cafe, —Ç–µ–º–Ω—ã–π', expected: true },
        { user: 'M√úDE, CAF√â, –¢–Å–ú–ù–´–ô', correct: 'mude, cafe, —Ç–µ–º–Ω—ã–π', expected: true },
      ];

      testCases.forEach(({ user, correct, expected }) => {
        it(`should ${expected ? 'accept' : 'reject'} "${user}" vs "${correct}"`, () => {
          expect(checkAnswer(user, correct)).toBe(expected);
        });
      });
    });

    describe('3.4 Documentation Examples', () => {
      const examples = [
        // Comma separation - multiple distinct meanings
        { user: '—ç—Ç–∞–∂, –∫–≤–∞—Ä—Ç–∏—Ä–∞', correct: '—ç—Ç–∞–∂, –∫–≤–∞—Ä—Ç–∏—Ä–∞', expected: true },
        { user: '–∫–≤–∞—Ä—Ç–∏—Ä–∞, —ç—Ç–∞–∂', correct: '—ç—Ç–∞–∂, –∫–≤–∞—Ä—Ç–∏—Ä–∞', expected: true },
        { user: '—ç—Ç–∞–∂', correct: '—ç—Ç–∞–∂, –∫–≤–∞—Ä—Ç–∏—Ä–∞', expected: false },
        { user: '–∫–≤–∞—Ä—Ç–∏—Ä–∞', correct: '—ç—Ç–∞–∂, –∫–≤–∞—Ä—Ç–∏—Ä–∞', expected: false },
        { user: '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é', correct: '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é', expected: true },
        { user: '–º–µ–Ω—é, –ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞', correct: '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é', expected: true },
        { user: '–ø–∏—Å—å–º–æ', correct: '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é', expected: false },
        { user: '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞', correct: '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é', expected: false },

        // Pipe separation - synonyms/alternatives
        { user: '—Å–ø–∞—Å–∏–±–æ', correct: '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é', expected: true },
        { user: '–±–ª–∞–≥–æ–¥–∞—Ä—é', correct: '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é', expected: true },
        { user: '–ø–æ–∂–∞–ª—É–π—Å—Ç–∞', correct: '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é', expected: false },
        { user: '–º–∞—à–∏–Ω–∞', correct: '–º–∞—à–∏–Ω–∞|–∞–≤—Ç–æ–º–æ–±–∏–ª—å', expected: true },
        { user: '–∞–≤—Ç–æ–º–æ–±–∏–ª—å', correct: '–º–∞—à–∏–Ω–∞|–∞–≤—Ç–æ–º–æ–±–∏–ª—å', expected: true },
        { user: '–º–∞—à–∏–Ω–∞, –∞–≤—Ç–æ–º–æ–±–∏–ª—å', correct: '–º–∞—à–∏–Ω–∞|–∞–≤—Ç–æ–º–æ–±–∏–ª—å', expected: false },

        // Parentheses grouping - multiple meanings with alternatives
        { user: '—Ä–∞–≤–Ω—ã–π, —Å–µ–π—á–∞—Å', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: true },
        { user: '–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, —Å—Ä–∞–∑—É', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: true },
        { user: '—Ä–∞–≤–Ω—ã–π, —Å—Ä–∞–∑—É', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: true },
        { user: '–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, —Å–µ–π—á–∞—Å', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: true },
        { user: '—Å–µ–π—á–∞—Å, —Ä–∞–≤–Ω—ã–π', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: true },
        { user: '—Ä–∞–≤–Ω—ã–π', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: false },
        { user: '—Å–µ–π—á–∞—Å', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: false },
        { user: '—Ä–∞–≤–Ω—ã–π, –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, —Å–µ–π—á–∞—Å', correct: '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)', expected: false },

        // Square brackets - optional clarifications
        { user: '–º–∏—Ä', correct: '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]', expected: true },
        { user: '–º–∏—Ä –≤—Å–µ–ª–µ–Ω–Ω–∞—è', correct: '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]', expected: true },
        { user: '–º–∏—Ä–≤—Å–µ–ª–µ–Ω–Ω–∞—è', correct: '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]', expected: true },
        { user: '–≤—Å–µ–ª–µ–Ω–Ω–∞—è', correct: '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]', expected: false },
        { user: '–º–∏—Ä, –≤—Å–µ–ª–µ–Ω–Ω–∞—è', correct: '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]', expected: false },
        { user: '—ç—Ç–∞–∂', correct: '—ç—Ç–∞–∂ [–∑–¥–∞–Ω–∏—è]', expected: true },
        { user: '—ç—Ç–∞–∂ –∑–¥–∞–Ω–∏—è', correct: '—ç—Ç–∞–∂ [–∑–¥–∞–Ω–∏—è]', expected: true },
        { user: '–∑–¥–∞–Ω–∏—è', correct: '—ç—Ç–∞–∂ [–∑–¥–∞–Ω–∏—è]', expected: false },

        // Mixed patterns
        { user: 'hello', correct: 'hello|hey|hi there|greetings', expected: true },
        { user: 'hey', correct: 'hello|hey|hi there|greetings', expected: true },
        { user: 'hi there', correct: 'hello|hey|hi there|greetings', expected: true },
        { user: 'greetings', correct: 'hello|hey|hi there|greetings', expected: true },
        { user: 'hello, greetings', correct: 'hello|hey|hi there|greetings', expected: false },
        { user: 'wrong', correct: 'hello|hey|hi there|greetings', expected: false },
      ];

      examples.forEach(({ user, correct, expected }) => {
        it(`should return ${expected} for user answer "${user}" and correct answer "${correct}"`, () => {
          expect(checkAnswer(user, correct)).toBe(expected);
        });
      });
    });

    describe('3.5 Edge Cases', () => {
      const edgeCases = [
        // Empty answers
        { user: '', correct: '', expected: true },
        { user: 'word', correct: '', expected: false },
        { user: '', correct: 'word', expected: false },

        // Whitespace handling
        { user: '  hello  ', correct: 'hello', expected: true },
        { user: 'hello', correct: '  hello  ', expected: true },
        { user: '  hello,  world  ', correct: 'hello, world', expected: true },

        // Case sensitivity
        { user: 'HELLO', correct: 'hello', expected: true },
        { user: 'Hello', correct: 'HELLO', expected: true },

        // Complex whitespace in comma-separated
        { user: 'word1 , word2 , word3', correct: 'word1, word2, word3', expected: true },

        // Malformed patterns gracefully handled
        { user: 'test', correct: 'test[incomplete', expected: false },
        { user: 'test', correct: 'incomplete]test', expected: false },
      ];

      edgeCases.forEach(({ user, correct, expected }) => {
        it(`should return ${expected} for edge case "${user}" vs "${correct}"`, () => {
          expect(checkAnswer(user, correct)).toBe(expected);
        });
      });
    });
  });

  describe('4. Bug Fixes - Issues from Screenshots', () => {
    const bugFixTests = [
      // Single word translations that were incorrectly rejected
      {
        description: 'Simple Spanish-Russian translation (broma ‚Üí —à—É—Ç–∫–∞)',
        user: '—à—É—Ç–∫–∞',
        correct: '—à—É—Ç–∫–∞',
        expected: true,
      },
      {
        description: 'Simple hearing verb (o√≠r ‚Üí —Å–ª—ã—à–∞—Ç—å)',
        user: '—Å–ª—ã—à–∞—Ç—å',
        correct: '—Å–ª—ã—à–∞—Ç—å',
        expected: true,
      },
      {
        description: 'Hearing verb with alternatives',
        user: '—Å–ª—ã—à–∞—Ç—å',
        correct: '—Å–ª—ã—à–∞—Ç—å|—É—Å–ª—ã—à–∞—Ç—å',
        expected: true,
      },

      // Complex phrase handling (simplified cases)
      {
        description: 'Simple phrase with alternatives',
        user: '–≤—ã–ø–æ–ª–Ω—è—Ç—å',
        correct: '(–≤—ã–ø–æ–ª–Ω—è—Ç—å|–∏—Å–ø–æ–ª–Ω—è—Ç—å)',
        expected: true,
      },
      {
        description: 'Complex phrase without optional part',
        user: '–≤—ã–ø–æ–ª–Ω—è—Ç—å',
        correct: '–≤—ã–ø–æ–ª–Ω—è—Ç—å [–æ–±–µ—â–∞–Ω–∏–µ –∏–ª–∏ –¥–æ–ª–≥]',
        expected: true,
      },

      // Age-related expressions with complex patterns
      {
        description: 'Age expression with complex pattern',
        user: '–∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è',
        correct: '(–≤—ã–ø–æ–ª–Ω—è—Ç—å|–∏—Å–ø–æ–ª–Ω—è—Ç—å), –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è [–æ –≤–æ–∑—Ä–∞—Å—Ç–µ]',
        expected: false, // Should require both parts
      },
      {
        description: 'Complete age expression',
        user: '–≤—ã–ø–æ–ª–Ω—è—Ç—å, –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è',
        correct: '(–≤—ã–ø–æ–ª–Ω—è—Ç—å|–∏—Å–ø–æ–ª–Ω—è—Ç—å), –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è [–æ –≤–æ–∑—Ä–∞—Å—Ç–µ]',
        expected: true,
      },
      {
        description: 'Age expression with alternative',
        user: '–∏—Å–ø–æ–ª–Ω—è—Ç—å, –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è',
        correct: '(–≤—ã–ø–æ–ª–Ω—è—Ç—å|–∏—Å–ø–æ–ª–Ω—è—Ç—å), –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è [–æ –≤–æ–∑—Ä–∞—Å—Ç–µ]',
        expected: true,
      },

      // Verb forms and conjugations
      {
        description: 'Infinitive vs past tense forms',
        user: '—Å–¥–µ–ª–∞–ª',
        correct: '–¥–µ–ª–∞—Ç—å',
        expected: false, // Different verb forms should not match
      },
      {
        description: 'Verb with multiple forms',
        user: '—Å–¥–µ–ª–∞–ª',
        correct: '–¥–µ–ª–∞—Ç—å|—Å–¥–µ–ª–∞—Ç—å|—Å–¥–µ–ª–∞–ª',
        expected: true,
      },

      // Preposition and directional issues
      {
        description: 'Preposition "above" vs verb "did"',
        user: '–Ω–∞–≤–µ—Ä—Ö—É',
        correct: 'encima',
        expected: false, // Wrong translation
      },
      {
        description: 'Above/over translation',
        user: '–Ω–∞–≤–µ—Ä—Ö—É',
        correct: '–Ω–∞–≤–µ—Ä—Ö—É|–≤—ã—à–µ|—Å–≤–µ—Ä—Ö—É',
        expected: true,
      },

      // Excitement and emotion verbs
      {
        description: 'Excitement verb alternatives',
        user: '–≤–æ–∑–±—É–∂–¥–∞—Ç—å',
        correct: 'excitar',
        expected: false, // Needs proper translation
      },
      {
        description: 'Proper excitement translation',
        user: '–≤–æ–∑–±—É–∂–¥–∞—Ç—å',
        correct: '–≤–æ–∑–±—É–∂–¥–∞—Ç—å|–≤–∑–≤–æ–ª–Ω–æ–≤–∞—Ç—å',
        expected: true,
      },

      // Together/joint expressions
      {
        description: 'Together expression',
        user: '–≤–º–µ—Å—Ç–µ',
        correct: 'junto',
        expected: false, // Wrong translation
      },
      {
        description: 'Proper together translation',
        user: '–≤–º–µ—Å—Ç–µ',
        correct: '–≤–º–µ—Å—Ç–µ|—Å–æ–≤–º–µ—Å—Ç–Ω–æ',
        expected: true,
      },

      // Complex reflexive verbs
      {
        description: 'Return reflexive verb',
        user: '–≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è',
        correct: '–≤–µ—Ä–Ω—É—Ç—å—Å—è',
        expected: false, // Different aspects
      },
      {
        description: 'Return verb with aspects',
        user: '–≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è',
        correct: '–≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è|–≤–µ—Ä–Ω—É—Ç—å—Å—è',
        expected: true,
      },

      // Case sensitivity in proper names and verbs
      {
        description: 'Capitalization in verb forms',
        user: 'regresar',
        correct: 'Regresar',
        expected: true, // Should be case insensitive
      },
    ];

    bugFixTests.forEach(({ description, user, correct, expected }) => {
      it(`${description}: "${user}" vs "${correct}" should be ${expected}`, () => {
        expect(checkAnswer(user, correct)).toBe(expected);
      });
    });
  });

  describe('5. Display Format Bug Fixes', () => {
    const displayBugTests = [
      // Complex pattern simplification for display
      {
        description: 'Complex age pattern should be simplified',
        input: '(–≤—ã–ø–æ–ª–Ω—è—Ç—å|–∏—Å–ø–æ–ª–Ω—è—Ç—å), –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è [–æ –≤–æ–∑—Ä–∞—Å—Ç–µ]',
        expected: '–≤—ã–ø–æ–ª–Ω—è—Ç—å, –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è [–æ –≤–æ–∑—Ä–∞—Å—Ç–µ]',
      },
      {
        description: 'Multiple parentheses groups with brackets',
        input: '(–¥–µ–ª–∞—Ç—å|—Å–æ–≤–µ—Ä—à–∞—Ç—å), (–¥–µ–π—Å—Ç–≤–∏–µ|–ø–æ—Å—Ç—É–ø–æ–∫) [–≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ —á–µ–≥–æ-—Ç–æ]',
        expected: '–¥–µ–ª–∞—Ç—å, –¥–µ–π—Å—Ç–≤–∏–µ [–≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ —á–µ–≥–æ-—Ç–æ]',
      },
      {
        description: 'Complex verb pattern with context',
        input: '(—Å–ª—ã—à–∞—Ç—å|—É—Å–ª—ã—à–∞—Ç—å), –≤–æ—Å–ø—Ä–∏–Ω–∏–º–∞—Ç—å [–∑–≤—É–∫]',
        expected: '—Å–ª—ã—à–∞—Ç—å, –≤–æ—Å–ø—Ä–∏–Ω–∏–º–∞—Ç—å [–∑–≤—É–∫]',
      },
      {
        description: 'Nested alternatives with clarification',
        input: '(–≤—ã–ø–æ–ª–Ω—è—Ç—å|–∏—Å–ø–æ–ª–Ω—è—Ç—å) (–æ–±–µ—â–∞–Ω–∏–µ|–¥–æ–ª–≥|–æ–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ)',
        expected: '–≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–±–µ—â–∞–Ω–∏–µ',
      },
    ];

    displayBugTests.forEach(({ description, input, expected }) => {
      it(`${description}: "${input}" should display as "${expected}"`, () => {
        expect(formatForDisplay(input)).toBe(expected);
      });
    });
  });

  describe('6. Integration Tests - Complex Real-World Scenarios', () => {
    const realWorldTests = [
      {
        description: 'German verb with multiple meanings',
        user: 'machen, tun',
        correct: '(machen|tun), (erstellen|schaffen)',
        expected: false, // Missing second group
      },
      {
        description: 'German verb with complete answer',
        user: 'machen, erstellen',
        correct: '(machen|tun), (erstellen|schaffen)',
        expected: true,
      },
      {
        description: 'Spanish with accents and multiple meanings',
        user: 'coraz√≥n, alma',
        correct: 'corazon, alma',
        expected: true,
      },
      {
        description: 'Russian with —ë/–µ and brackets',
        user: '—Ç—ë–º–Ω—ã–π —á–µ–ª–æ–≤–µ–∫',
        correct: '—Ç–µ–º–Ω—ã–π [—á–µ–ª–æ–≤–µ–∫]',
        expected: true,
      },
      {
        description: 'Complex mixed language pattern',
        user: 'caf√©, –º–∏—Ä, sch√∂n',
        correct: 'cafe, –º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è], schoen',
        expected: true,
      },
      {
        description: 'Verb with reflexive suffix',
        user: '–ø–∞—Ä–∫–æ–≤–∞—Ç—å—Å—è',
        correct: '–ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]',
        expected: true,
      },
      {
        description: 'Multiple alternatives with normalization',
        user: 'mude',
        correct: 'm√ºde|tired|ersch√∂pft',
        expected: true,
      },
    ];

    realWorldTests.forEach(({ description, user, correct, expected }) => {
      it(`${description}: "${user}" vs "${correct}" should be ${expected}`, () => {
        expect(checkAnswer(user, correct)).toBe(expected);
      });
    });
  });
});
