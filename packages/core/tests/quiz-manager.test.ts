import { describe, it, expect, beforeEach } from 'vitest';
import { QuizManager, Translation, checkAnswer, formatForDisplay, K, F } from '../src/index';

describe('Text Processing Functions', () => {
  describe('formatForDisplay', () => {
    it('should handle pipe alternatives', () => {
      expect(formatForDisplay('hello|hi|hey')).toBe('hello');
      expect(formatForDisplay('–ø—Ä–∏–≤–µ—Ç|–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π')).toBe('–ø—Ä–∏–≤–µ—Ç');
    });

    it('should preserve brackets, commas, and parentheses', () => {
      expect(formatForDisplay('word[s]')).toBe('word[s]');
      expect(formatForDisplay('red, blue')).toBe('red, blue');
      expect(formatForDisplay('word (context)')).toBe('word (context)');
    });

    it('should handle parentheses groups with pipes - showing only first alternative without parentheses', () => {
      // Test cases from the bug report
      expect(formatForDisplay('(–º–µ–Ω—è—Ç—å|–∏–∑–º–µ–Ω—è—Ç—å), (–∏–∑–º–µ–Ω–µ–Ω–∏–µ|—Å–º–µ–Ω–∞)')).toBe('–º–µ–Ω—è—Ç—å, –∏–∑–º–µ–Ω–µ–Ω–∏–µ');
      expect(formatForDisplay('(—Ç—Ä—É–¥–Ω—ã–π|—Å–ª–æ–∂–Ω—ã–π), (—Ç–≤—ë—Ä–¥—ã–π|–∂—ë—Å—Ç–∫–∏–π), —É—Å–µ—Ä–¥–Ω–æ')).toBe('—Ç—Ä—É–¥–Ω—ã–π, —Ç–≤—ë—Ä–¥—ã–π, —É—Å–µ—Ä–¥–Ω–æ');
      expect(formatForDisplay('(–º–∞—Ç—á|—Å–æ—Ä–µ–≤–Ω–æ–≤–∞–Ω–∏–µ), —Å–ø–∏—á–∫–∞, (–ø–æ–¥—Ö–æ–¥–∏—Ç—å|—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å)')).toBe('–º–∞—Ç—á, —Å–ø–∏—á–∫–∞, –ø–æ–¥—Ö–æ–¥–∏—Ç—å');
      expect(formatForDisplay('(–∑–Ω–∞—á–∏—Ç—å|–æ–∑–Ω–∞—á–∞—Ç—å), –∏–º–µ—Ç—å –≤ –≤–∏–¥—É')).toBe('–∑–Ω–∞—á–∏—Ç—å, –∏–º–µ—Ç—å –≤ –≤–∏–¥—É');
      expect(formatForDisplay('(–¥–≤–∏–≥–∞—Ç—å|–ø–µ—Ä–µ–º–µ—â–∞—Ç—å), –ø–µ—Ä–µ–µ–∑–∂–∞—Ç—å, –¥–≤–∏–∂–µ–Ω–∏–µ')).toBe('–¥–≤–∏–≥–∞—Ç—å, –ø–µ—Ä–µ–µ–∑–∂–∞—Ç—å, –¥–≤–∏–∂–µ–Ω–∏–µ');
      expect(formatForDisplay('(–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å')).toBe('–∑–∞–ø–∏—Å–∫–∞, –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å');
    });

    it('should handle complex mixed formats', () => {
      // Parentheses without pipes should be preserved as-is
      expect(formatForDisplay('word (context), another')).toBe('word (context), another');
      // Single parentheses group with pipes
      expect(formatForDisplay('(option1|option2|option3)')).toBe('option1');
      // Mixed parentheses - some with pipes, some without
      expect(formatForDisplay('(a|b), (context), (x|y|z)')).toBe('a, (context), x');
    });

    it('should handle real-world documentation examples', () => {
      // Example from docs: banco ‚Üí –±–∞–Ω–∫, —Å–∫–∞–º–µ–π–∫–∞
      expect(formatForDisplay('–±–∞–Ω–∫, —Å–∫–∞–º–µ–π–∫–∞')).toBe('–±–∞–Ω–∫, —Å–∫–∞–º–µ–π–∫–∞');

      // Example from docs: bonito|hermoso|lindo
      expect(formatForDisplay('bonito|hermoso|lindo')).toBe('bonito');

      // Example from docs: paz ‚Üí –º–∏—Ä [–≥–∞—Ä–º–æ–Ω–∏—è]
      expect(formatForDisplay('–º–∏—Ä [–≥–∞—Ä–º–æ–Ω–∏—è]')).toBe('–º–∏—Ä [–≥–∞—Ä–º–æ–Ω–∏—è]');

      // Example from docs: planta ‚Üí —ç—Ç–∞–∂ (–∑–¥–∞–Ω–∏—è)
      expect(formatForDisplay('—ç—Ç–∞–∂ (–∑–¥–∞–Ω–∏—è)')).toBe('—ç—Ç–∞–∂ (–∑–¥–∞–Ω–∏—è)');

      // Example from docs: –º–∞—à–∏–Ω–∞|–∞–≤—Ç–æ–º–æ–±–∏–ª—å
      expect(formatForDisplay('–º–∞—à–∏–Ω–∞|–∞–≤—Ç–æ–º–æ–±–∏–ª—å')).toBe('–º–∞—à–∏–Ω–∞');
    });

    it('should handle nested and complex patterns', () => {
      // Multiple parentheses groups in succession
      expect(formatForDisplay('(a|b)(c|d)(e|f)')).toBe('ace');

      // Parentheses groups with commas and other text
      expect(formatForDisplay('prefix, (option1|option2), suffix, (choice1|choice2)')).toBe('prefix, option1, suffix, choice1');

      // Empty parentheses (edge case)
      expect(formatForDisplay('word ()')).toBe('word'); // Empty parentheses should be removed
      expect(formatForDisplay('word (|)')).toBe('word'); // Empty alternative should be removed

      // Single pipe at start/end of parentheses
      expect(formatForDisplay('(|option)')).toBe('option');
      expect(formatForDisplay('(option|)')).toBe('option');
    });

    it('should handle whitespace variations', () => {
      // Spaces around pipes
      expect(formatForDisplay('hello | hi | hey')).toBe('hello');
      expect(formatForDisplay('(option1 | option2 | option3)')).toBe('option1');

      // Tabs and multiple spaces
      expect(formatForDisplay('hello\t|\thi')).toBe('hello');
      expect(formatForDisplay('(a  |  b), (c|d)')).toBe('a, c');

      // Leading/trailing spaces in alternatives
      expect(formatForDisplay('( space1 | space2 )')).toBe('space1');
    });

    it('should preserve non-parentheses formatting', () => {
      // Square brackets should always be preserved
      expect(formatForDisplay('word[suffix]')).toBe('word[suffix]');
      expect(formatForDisplay('prefix[opt1|opt2]suffix')).toBe('prefix[opt1|opt2]suffix');

      // Commas should always be preserved
      expect(formatForDisplay('first, second, third')).toBe('first, second, third');

      // Regular parentheses without pipes should be preserved
      expect(formatForDisplay('word (explanation)')).toBe('word (explanation)');
      expect(formatForDisplay('multiple (words) with (context)')).toBe('multiple (words) with (context)');
    });

    it('should handle malformed input gracefully', () => {
      // Unmatched brackets/parentheses
      expect(formatForDisplay('word[incomplete')).toBe('word[incomplete');
      expect(formatForDisplay('incomplete]word')).toBe('incomplete]word');
      expect(formatForDisplay('word(incomplete')).toBe('word(incomplete');
      expect(formatForDisplay('incomplete)word')).toBe('incomplete)word');

      // Empty alternatives
      expect(formatForDisplay('word||another')).toBe('word');
      expect(formatForDisplay('||word')).toBe('');
      expect(formatForDisplay('word||')).toBe('word');

      // Empty parentheses groups - should be cleaned up
      expect(formatForDisplay('()')).toBe('');
      expect(formatForDisplay('word, ()')).toBe('word');
      expect(formatForDisplay('()|valid')).toBe('');

      // Only separators
      expect(formatForDisplay('|||')).toBe('');
      expect(formatForDisplay('((()))')).toBe(''); // Should remove all empty parentheses
    });

    it('should handle unicode and special characters', () => {
      // Unicode characters in alternatives
      expect(formatForDisplay('caf√©|na√Øve')).toBe('caf√©');
      expect(formatForDisplay('üòÄ|üòÉ')).toBe('üòÄ');

      // Mixed scripts
      expect(formatForDisplay('English|–†—É—Å—Å–∫–∏–π')).toBe('English');
      expect(formatForDisplay('(option1|–≤–∞—Ä–∏–∞–Ω—Ç2)')).toBe('option1');

      // Special whitespace characters
      expect(formatForDisplay('word\t|\tother')).toBe('word');
      expect(formatForDisplay('word\u00A0|other')).toBe('word'); // Non-breaking space
    });
  });

  describe('checkAnswer', () => {
    it('should handle basic matching', () => {
      expect(checkAnswer('hello', 'hello')).toBe(true);
      expect(checkAnswer('Hello', 'hello')).toBe(true);
      expect(checkAnswer('hello', 'world')).toBe(false);
    });

    it('should handle pipe alternatives', () => {
      expect(checkAnswer('hello', 'hello|hi|hey')).toBe(true);
      expect(checkAnswer('hi', 'hello|hi|hey')).toBe(true);
      expect(checkAnswer('world', 'hello|hi|hey')).toBe(false);
    });

    it('should handle bracket optional parts', () => {
      expect(checkAnswer('good morning', 'good [morning]')).toBe(true);
      expect(checkAnswer('good', 'good [morning]')).toBe(true);
      expect(checkAnswer('morning', 'good [morning]')).toBe(false);
    });

    it('should handle bracket optional parts without spaces', () => {
      // Test case from bug report: –ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]
      expect(checkAnswer('–ø–∞—Ä–∫–æ–≤–∞—Ç—å', '–ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]')).toBe(true);
      expect(checkAnswer('–ø–∞—Ä–∫–æ–≤–∞—Ç—å—Å—è', '–ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]')).toBe(true);
      expect(checkAnswer('–ø–∞—Ä–∫–æ–≤–∞—Ç—å —Å—è', '–ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]')).toBe(true);

      // More test cases
      expect(checkAnswer('test', 'test[ing]')).toBe(true);
      expect(checkAnswer('testing', 'test[ing]')).toBe(true);
      expect(checkAnswer('test ing', 'test[ing]')).toBe(true);

      // Should not accept just the optional part
      expect(checkAnswer('—Å—è', '–ø–∞—Ä–∫–æ–≤–∞—Ç—å[—Å—è]')).toBe(false);
      expect(checkAnswer('ing', 'test[ing]')).toBe(false);
    });

    it('should handle comma-separated required parts', () => {
      expect(checkAnswer('red, blue', 'red, blue')).toBe(true);
      expect(checkAnswer('blue, red', 'red, blue')).toBe(true);
      expect(checkAnswer('red', 'red, blue')).toBe(false);
      expect(checkAnswer('blue', 'red, blue')).toBe(false);

      // Real example from docs: carta (letter, card, menu)
      expect(checkAnswer('–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é')).toBe(true);
      expect(checkAnswer('–º–µ–Ω—é, –ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é')).toBe(true);
      expect(checkAnswer('–ø–∏—Å—å–º–æ', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é')).toBe(false);
      expect(checkAnswer('–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞, –º–µ–Ω—é')).toBe(false);
    });

    it('should handle parentheses grouping with pipes', () => {
      // Real example from docs: gleich ‚Üí (—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)
      const answer = '(—Ä–∞–≤–Ω—ã–π|–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π), (—Å–µ–π—á–∞—Å|—Å—Ä–∞–∑—É)';

      // ‚úÖ Valid combinations - one from each group
      expect(checkAnswer('—Ä–∞–≤–Ω—ã–π, —Å–µ–π—á–∞—Å', answer)).toBe(true);
      expect(checkAnswer('–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, —Å—Ä–∞–∑—É', answer)).toBe(true);
      expect(checkAnswer('—Ä–∞–≤–Ω—ã–π, —Å—Ä–∞–∑—É', answer)).toBe(true);
      expect(checkAnswer('–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, —Å–µ–π—á–∞—Å', answer)).toBe(true);
      expect(checkAnswer('—Å–µ–π—á–∞—Å, —Ä–∞–≤–Ω—ã–π', answer)).toBe(true); // Order doesn't matter

      // ‚ùå Invalid - incomplete (missing one group)
      expect(checkAnswer('—Ä–∞–≤–Ω—ã–π', answer)).toBe(false);
      expect(checkAnswer('—Å–µ–π—á–∞—Å', answer)).toBe(false);

      // ‚ùå Invalid - treating as 3 separate meanings
      expect(checkAnswer('—Ä–∞–≤–Ω—ã–π, –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, —Å–µ–π—á–∞—Å', answer)).toBe(false);

      // ‚ùå Invalid - wrong words
      expect(checkAnswer('–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ, —Å–ª–æ–≤–æ', answer)).toBe(false);
    });

    it('should handle Cyrillic normalization in answers', () => {
      // —ë/–µ equivalence
      expect(checkAnswer('—Ç—ë–º–Ω—ã–π', '—Ç–µ–º–Ω—ã–π')).toBe(true);
      expect(checkAnswer('—Ç–µ–º–Ω—ã–π', '—Ç—ë–º–Ω—ã–π')).toBe(true);
      expect(checkAnswer('–¢–Å–ú–ù–´–ô', '—Ç–µ–º–Ω—ã–π')).toBe(true);

      // In pipe alternatives
      expect(checkAnswer('—Ç—ë–º–Ω—ã–π', '—Ç–µ–º–Ω—ã–π|—á—ë—Ä–Ω—ã–π')).toBe(true);
      expect(checkAnswer('—á—ë—Ä–Ω—ã–π', '—Ç–µ–º–Ω—ã–π|—á–µ—Ä–Ω—ã–π')).toBe(true);

      // In comma-separated parts
      expect(checkAnswer('—Ç—ë–º–Ω—ã–π, —á—ë—Ä–Ω—ã–π', '—Ç–µ–º–Ω—ã–π, —á–µ—Ä–Ω—ã–π')).toBe(true);
      expect(checkAnswer('—á–µ—Ä–Ω—ã–π, —Ç—ë–º–Ω—ã–π', '—Ç–µ–º–Ω—ã–π, —á—ë—Ä–Ω—ã–π')).toBe(true);
    });

    it('should handle Latin to Cyrillic conversion in answers', () => {
      // Basic conversion
      expect(checkAnswer('cop', '—Å–æ—Ä')).toBe(true);
      expect(checkAnswer('—Å–æ—Ä', 'cop')).toBe(true);
      expect(checkAnswer('COP', '—Å–æ—Ä')).toBe(true);

      // In pipe alternatives
      expect(checkAnswer('cop', '—Å–æ—Ä|–º—É—Å–æ—Ä')).toBe(true);
      expect(checkAnswer('–º—É—Å–æ—Ä', 'cop|–º—É—Å–æ—Ä')).toBe(true);

      // In comma-separated parts
      expect(checkAnswer('cop, –º—É—Å–æ—Ä', '—Å–æ—Ä, –º—É—Å–æ—Ä')).toBe(true);
      expect(checkAnswer('—Å–æ—Ä, –º—É—Å–æ—Ä', 'cop, –º—É—Å–æ—Ä')).toBe(true);
    });

    it('should handle Spanish accent normalization in answers', () => {
      // Basic Spanish accents
      expect(checkAnswer('cafe', 'caf√©')).toBe(true);
      expect(checkAnswer('caf√©', 'cafe')).toBe(true);
      expect(checkAnswer('nino', 'ni√±o')).toBe(true);
      expect(checkAnswer('ni√±o', 'nino')).toBe(true);
      expect(checkAnswer('corazon', 'coraz√≥n')).toBe(true);
      expect(checkAnswer('espanol', 'espa√±ol')).toBe(true);

      // In pipe alternatives
      expect(checkAnswer('cafe', 'caf√©|coffee')).toBe(true);
      expect(checkAnswer('coffee', 'caf√©|coffee')).toBe(true);
      expect(checkAnswer('caf√©', 'cafe|coffee')).toBe(true);

      // In comma-separated parts
      expect(checkAnswer('cafe, nino', 'caf√©, ni√±o')).toBe(true);
      expect(checkAnswer('caf√©, ni√±o', 'cafe, nino')).toBe(true);

      // Mixed case
      expect(checkAnswer('M√âXICO', 'mexico')).toBe(true);
      expect(checkAnswer('educaci√≥n', 'EDUCACION')).toBe(true);
    });

    it('should handle German umlaut normalization in answers', () => {
      // Basic German umlauts
      expect(checkAnswer('mude', 'm√ºde')).toBe(true);
      expect(checkAnswer('m√ºde', 'mude')).toBe(true);
      expect(checkAnswer('uber', '√ºber')).toBe(true);
      expect(checkAnswer('√ºber', 'uber')).toBe(true);
      expect(checkAnswer('schon', 'sch√∂n')).toBe(true);
      expect(checkAnswer('grosse', 'gr√∂√üe')).toBe(true);

      // German letter + e equivalents
      expect(checkAnswer('muede', 'm√ºde')).toBe(true);
      expect(checkAnswer('m√ºde', 'muede')).toBe(true);
      expect(checkAnswer('ueber', '√ºber')).toBe(true);
      expect(checkAnswer('√ºber', 'ueber')).toBe(true);
      expect(checkAnswer('schoen', 'sch√∂n')).toBe(true);
      expect(checkAnswer('sch√∂n', 'schoen')).toBe(true);
      expect(checkAnswer('groesse', 'gr√∂√üe')).toBe(true);
      expect(checkAnswer('gr√∂√üe', 'groesse')).toBe(true);

      // In pipe alternatives
      expect(checkAnswer('mude', 'm√ºde|tired')).toBe(true);
      expect(checkAnswer('muede', 'm√ºde|tired')).toBe(true);
      expect(checkAnswer('tired', 'm√ºde|tired')).toBe(true);
      expect(checkAnswer('m√ºde', 'mude|tired')).toBe(true);

      // In comma-separated parts
      expect(checkAnswer('mude, schon', 'm√ºde, sch√∂n')).toBe(true);
      expect(checkAnswer('muede, schoen', 'm√ºde, sch√∂n')).toBe(true);
      expect(checkAnswer('m√ºde, sch√∂n', 'mude, schon')).toBe(true);

      // Mixed case
      expect(checkAnswer('√úBER', 'uber')).toBe(true);
      expect(checkAnswer('UEBER', '√ºber')).toBe(true);
      expect(checkAnswer('gr√∂√üe', 'GROSSE')).toBe(true);
      expect(checkAnswer('gr√∂√üe', 'GROESSE')).toBe(true);
    });

    it('should handle mixed language normalization in answers', () => {
      // Spanish + German
      expect(checkAnswer('cafe mude', 'caf√© m√ºde')).toBe(true);
      expect(checkAnswer('ni√±o √ºber', 'nino uber')).toBe(true);

      // With pipes
      expect(checkAnswer('cafe', 'caf√©|m√ºde')).toBe(true);
      expect(checkAnswer('mude', 'caf√©|m√ºde')).toBe(true);

      // With commas
      expect(checkAnswer('espa√±ol, sch√∂n', 'espanol, schon')).toBe(true);
      expect(checkAnswer('coraz√≥n, gr√∂√üe', 'corazon, grosse')).toBe(true);
    });

    it('should handle complex bracket scenarios', () => {
      // Multiple words before/after brackets
      expect(checkAnswer('good morning coffee', 'good morning [coffee]')).toBe(true);
      expect(checkAnswer('good morning', 'good morning [coffee]')).toBe(true);
      expect(checkAnswer('coffee', 'good morning [coffee]')).toBe(false);

      // Brackets in middle
      expect(checkAnswer('word context here', 'word [context] here')).toBe(true);
      expect(checkAnswer('word here', 'word [context] here')).toBe(true);
      expect(checkAnswer('wordcontexthere', 'word [context] here')).toBe(true);
      expect(checkAnswer('word contexthere', 'word [context] here')).toBe(true);

      // Real examples from docs
      expect(checkAnswer('–º–∏—Ä', '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–º–∏—Ä –≤—Å–µ–ª–µ–Ω–Ω–∞—è', '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–º–∏—Ä–≤—Å–µ–ª–µ–Ω–Ω–∞—è', '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–≤—Å–µ–ª–µ–Ω–Ω–∞—è', '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]')).toBe(false);
      expect(checkAnswer('–º–∏—Ä, –≤—Å–µ–ª–µ–Ω–Ω–∞—è', '–º–∏—Ä [–≤—Å–µ–ª–µ–Ω–Ω–∞—è]')).toBe(false);
    });

    it('should handle edge cases and invalid inputs', () => {
      // Empty strings
      expect(checkAnswer('', '')).toBe(true);
      expect(checkAnswer('', 'word')).toBe(false);
      expect(checkAnswer('word', '')).toBe(false);

      // Whitespace handling
      expect(checkAnswer('  word  ', 'word')).toBe(true);
      expect(checkAnswer('word', '  word  ')).toBe(true);
      expect(checkAnswer('  red  ,  blue  ', 'red, blue')).toBe(true);

      // Special characters that should be ignored
      expect(checkAnswer('word', 'word')).toBe(true);
      expect(checkAnswer('word!', 'word')).toBe(false); // Punctuation matters
    });

    it('should handle mixed format combinations', () => {
      // Pipes with brackets: —Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º] means "—Å–ø–∞—Å–∏–±–æ" OR "–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]"
      expect(checkAnswer('—Å–ø–∞—Å–∏–±–æ', '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]')).toBe(true);
      expect(checkAnswer('–±–ª–∞–≥–æ–¥–∞—Ä—é', '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]')).toBe(true);
      expect(checkAnswer('–±–ª–∞–≥–æ–¥–∞—Ä—é –≤–∞–º', '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]')).toBe(true);
      expect(checkAnswer('–±–ª–∞–≥–æ–¥–∞—Ä—é–≤–∞–º', '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]')).toBe(true);

      // These should be false - brackets don't apply to first alternative
      expect(checkAnswer('—Å–ø–∞—Å–∏–±–æ –≤–∞–º', '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]')).toBe(false);
      expect(checkAnswer('—Å–ø–∞—Å–∏–±–æ–≤–∞–º', '—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é [–≤–∞–º]')).toBe(false);

      // Commas with brackets: –ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ [–∏–≥—Ä–∞–ª—å–Ω–∞—è]
      expect(checkAnswer('–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ [–∏–≥—Ä–∞–ª—å–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ –∏–≥—Ä–∞–ª—å–Ω–∞—è', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ [–∏–≥—Ä–∞–ª—å–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞–∏–≥—Ä–∞–ª—å–Ω–∞—è', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ [–∏–≥—Ä–∞–ª—å–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–∫–∞—Ä—Ç–∞, –ø–∏—Å—å–º–æ', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ [–∏–≥—Ä–∞–ª—å–Ω–∞—è]')).toBe(true);
      expect(checkAnswer('–ø–∏—Å—å–º–æ', '–ø–∏—Å—å–º–æ, –∫–∞—Ä—Ç–∞ [–∏–≥—Ä–∞–ª—å–Ω–∞—è]')).toBe(false);

      // Parentheses with brackets: (–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å
      expect(checkAnswer('–∑–∞–ø–∏—Å–∫–∞, –Ω–æ—Ç–∞, –∑–∞–º–µ—á–∞—Ç—å', '(–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å')).toBe(true);
      expect(checkAnswer('–∑–∞–º–µ—Ç–∫–∞, –Ω–æ—Ç–∞ –º—É–∑—ã–∫–∞, –∑–∞–º–µ—á–∞—Ç—å', '(–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å')).toBe(true);
      expect(checkAnswer('–∑–∞–ø–∏—Å–∫–∞, –Ω–æ—Ç–∞–º—É–∑—ã–∫–∞, –∑–∞–º–µ—á–∞—Ç—å', '(–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å')).toBe(true);
      expect(checkAnswer('–∑–∞–ø–∏—Å–∫–∞, –Ω–æ—Ç–∞', '(–∑–∞–ø–∏—Å–∫–∞|–∑–∞–º–µ—Ç–∫–∞), –Ω–æ—Ç–∞ [–º—É–∑—ã–∫–∞], –∑–∞–º–µ—á–∞—Ç—å')).toBe(false);
    });
  });
});

describe('QuizManager', () => {
  let mockTranslations: Translation[];
  let quizManager: QuizManager;

  beforeEach(() => {
    mockTranslations = [
      {
        id: 1,
        sourceWord: { text: 'hello', language: 'en', usageExample: 'Hello world!' },
        targetWord: { text: '–ø—Ä–∏–≤–µ—Ç', language: 'ru', usageExample: '–ü—Ä–∏–≤–µ—Ç –º–∏—Ä!' },
      },
      {
        id: 2,
        sourceWord: { text: 'world', language: 'en', usageExample: 'Hello world!' },
        targetWord: { text: '–º–∏—Ä', language: 'ru', usageExample: '–ü—Ä–∏–≤–µ—Ç –º–∏—Ä!' },
      },
      {
        id: 3,
        sourceWord: { text: 'cat', language: 'en' },
        targetWord: { text: '–∫–æ—Ç', language: 'ru' },
      },
    ];

    quizManager = new QuizManager(mockTranslations);
  });

  describe('initialization', () => {
    it('should initialize with correct default state', () => {
      const state = quizManager.getState();
      expect(state.currentLevel).toBe('LEVEL_1');
      expect(state.progress).toHaveLength(3);

      // All words should start in focus pool (LEVEL_1) due to replenishFocusPool
      const level1Words = state.progress.filter((p) => p.status === 'LEVEL_1');
      expect(level1Words).toHaveLength(3);
    });

    it('should initialize with custom options', () => {
      const customManager = new QuizManager(
        mockTranslations,
        {},
        {
          maxFocusWords: 5,
          correctAnswersToLevelUp: 5,
          enableUsageExamples: false,
        }
      );

      const options = customManager.getOptions();
      expect(options.maxFocusWords).toBe(5);
      expect(options.correctAnswersToLevelUp).toBe(5);
      expect(options.enableUsageExamples).toBe(false);
    });

    it('should restore from initial state', () => {
      const initialState = {
        progress: [
          {
            translationId: 1,
            status: 'LEVEL_2' as const,
            queuePosition: 0,
            consecutiveCorrect: 2,
            recentHistory: [true, true],
          },
        ],
        currentLevel: 'LEVEL_2' as const,
      };

      const restoredManager = new QuizManager(mockTranslations, initialState);
      const state = restoredManager.getState();

      expect(state.currentLevel).toBe('LEVEL_2');
      const progress1 = state.progress.find((p) => p.translationId === 1);
      expect(progress1?.status).toBe('LEVEL_2');
      expect(progress1?.consecutiveCorrect).toBe(2);
    });
  });

  describe('question generation', () => {
    it('should generate a valid question', () => {
      const result = quizManager.getNextQuestion();
      expect(result.question).toBeDefined();

      if (result.question) {
        expect(result.question.translationId).toBeDefined();
        expect(result.question.questionText).toBeDefined();
        expect(result.question.level).toBe('LEVEL_1');
        expect(result.question.direction).toBe('normal');
        expect(result.question.questionType).toBe('translation');
      }
    });

    it('should handle different levels correctly', () => {
      // Move some words to LEVEL_2 first
      quizManager.submitAnswer(1, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(1, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(1, '–ø—Ä–∏–≤–µ—Ç'); // Should promote to LEVEL_2

      // Set level to LEVEL_2 (reverse direction)
      const setResult = quizManager.setLevel('LEVEL_2');
      expect(setResult.success).toBe(true);

      const result = quizManager.getNextQuestion();
      if (result.question) {
        expect(result.question.level).toBe('LEVEL_2');
        expect(result.question.direction).toBe('reverse');
      }
    });

    it('should auto-adjust level when no words available', () => {
      // Try to set a level with no words
      const setResult = quizManager.setLevel('LEVEL_3');
      expect(setResult.success).toBe(false);
      expect(setResult.actualLevel).toBe('LEVEL_1');
      expect(setResult.message).toContain('LEVEL_3 has no available words');
    });
  });

  describe('answer submission and progression', () => {
    it('should handle correct answers', () => {
      const question = quizManager.getNextQuestion().question!;
      const result = quizManager.submitAnswer(question.translationId, '–ø—Ä–∏–≤–µ—Ç');

      expect(result.isCorrect).toBe(true);
      expect(result.correctAnswerText).toBe('–ø—Ä–∏–≤–µ—Ç');
      expect(result.submittedAnswerText).toBe('–ø—Ä–∏–≤–µ—Ç');
      expect(result.translation).toBeDefined();
    });

    it('should handle incorrect answers', () => {
      const question = quizManager.getNextQuestion().question!;
      const result = quizManager.submitAnswer(question.translationId, 'wrong');

      expect(result.isCorrect).toBe(false);
      expect(result.correctAnswerText).toBe('–ø—Ä–∏–≤–µ—Ç');
      expect(result.submittedAnswerText).toBe('wrong');
    });

    it('should track consecutive correct answers', () => {
      const question = quizManager.getNextQuestion().question!;
      const translationId = question.translationId;

      // Submit 2 correct answers
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');

      const state = quizManager.getState();
      const progress = state.progress.find((p) => p.translationId === translationId);
      expect(progress?.consecutiveCorrect).toBe(2);
      expect(progress?.status).toBe('LEVEL_1'); // Not promoted yet

      // Third correct answer should promote
      const result = quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');
      expect(result.levelChange).toBeDefined();
      expect(result.levelChange?.from).toBe('LEVEL_1');
      expect(result.levelChange?.to).toBe('LEVEL_2');
    });

    it('should handle word degradation after mistakes', () => {
      // First, promote a word to LEVEL_2
      const question = quizManager.getNextQuestion().question!;
      const translationId = question.translationId;

      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç'); // Promoted to LEVEL_2

      // Now make 3 mistakes
      quizManager.submitAnswer(translationId, 'wrong1');
      quizManager.submitAnswer(translationId, 'wrong2');
      const result = quizManager.submitAnswer(translationId, 'wrong3');

      // Should be degraded back to LEVEL_1
      const state = quizManager.getState();
      const progress = state.progress.find((p) => p.translationId === translationId);
      expect(progress?.status).toBe('LEVEL_1');
    });

    it('should reset consecutive counter after wrong answer', () => {
      const question = quizManager.getNextQuestion().question!;
      const translationId = question.translationId;

      // Submit 2 correct answers
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');

      // Submit wrong answer
      quizManager.submitAnswer(translationId, 'wrong');

      const state = quizManager.getState();
      const progress = state.progress.find((p) => p.translationId === translationId);
      expect(progress?.consecutiveCorrect).toBe(0);
    });
  });

  describe('queue management', () => {
    it('should manage queue positions correctly', () => {
      const question = quizManager.getNextQuestion().question!;
      const translationId = question.translationId;
      const initialState = quizManager.getState();

      // Get initial queue state
      const level1Queue = [...initialState.queues.LEVEL_1];
      expect(level1Queue[0]).toBe(translationId); // Should be first

      // Submit correct answer
      quizManager.submitAnswer(translationId, '–ø—Ä–∏–≤–µ—Ç');

      const newState = quizManager.getState();
      const newLevel1Queue = newState.queues.LEVEL_1;

      // Word should be moved to position (K √ó F) √ó consecutiveCorrect
      // With a 3-word queue, position (K √ó F) should place it at the end
      const expectedQueuePosition = K * F * 1; // 1 consecutive correct answer
      const queueLength = newLevel1Queue.length;
      const expectedIndex = Math.min(expectedQueuePosition, queueLength - 1);

      const newPosition = newLevel1Queue.indexOf(translationId);
      expect(newPosition).toBe(expectedIndex);
    });

    it('should handle queue replenishment', () => {
      // All words should start in LEVEL_1 due to replenishFocusPool
      const state = quizManager.getState();
      const level1Count = state.progress.filter((p) => p.status === 'LEVEL_1').length;
      expect(level1Count).toBe(3); // All words moved from LEVEL_0 to LEVEL_1
    });
  });

  describe('statistics and completion', () => {
    it('should calculate statistics correctly', () => {
      const stats = quizManager.getStatistics();

      expect(stats.totalWords).toBe(3);
      expect(stats.levelCounts.LEVEL_0).toBe(0); // All moved to LEVEL_1
      expect(stats.levelCounts.LEVEL_1).toBe(3);
      expect(stats.completionPercentage).toBe(0);
      expect(stats.isComplete).toBe(false);
    });

    it('should track completion progress', () => {
      // Promote all words to completion level (LEVEL_3 or LEVEL_5 depending on options)
      const targetLevel = quizManager.getOptions().enableUsageExamples ? 'LEVEL_5' : 'LEVEL_3';

      // For simplicity, manually set all words to target level
      const state = quizManager.getState();
      state.progress.forEach((p) => {
        p.status = targetLevel as any;
      });

      const stats = quizManager.getStatistics();
      expect(stats.completionPercentage).toBe(100);
      expect(stats.isComplete).toBe(true);
    });
  });

  describe('level switching', () => {
    it('should switch levels successfully when words are available', () => {
      // First promote a word to LEVEL_2
      const question = quizManager.getNextQuestion().question!;
      quizManager.submitAnswer(question.translationId, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(question.translationId, '–ø—Ä–∏–≤–µ—Ç');
      quizManager.submitAnswer(question.translationId, '–ø—Ä–∏–≤–µ—Ç');

      // Now switch to LEVEL_2
      const result = quizManager.setLevel('LEVEL_2');
      expect(result.success).toBe(true);
      expect(result.actualLevel).toBe('LEVEL_2');
      expect(quizManager.getCurrentLevel()).toBe('LEVEL_2');
    });

    it('should auto-adjust to available level when requested level is empty', () => {
      // Try to switch to LEVEL_3 (which has no words)
      const result = quizManager.setLevel('LEVEL_3');
      expect(result.success).toBe(false);
      expect(result.actualLevel).toBe('LEVEL_1');
      expect(result.message).toContain('LEVEL_3 has no available words');
    });
  });

  describe('translation utilities', () => {
    it('should get translation by ID', () => {
      const translation = quizManager.getTranslation(1);
      expect(translation).toBeDefined();
      expect(translation?.sourceWord.text).toBe('hello');
      expect(translation?.targetWord.text).toBe('–ø—Ä–∏–≤–µ—Ç');
    });

    it('should get formatted translation for display', () => {
      const formatted = quizManager.getTranslationForDisplay(1);
      expect(formatted).toBeDefined();
      expect(formatted?.source).toBe('hello');
      expect(formatted?.target).toBe('–ø—Ä–∏–≤–µ—Ç');
    });

    it('should return undefined for non-existent translation', () => {
      const translation = quizManager.getTranslation(999);
      expect(translation).toBeUndefined();

      const formatted = quizManager.getTranslationForDisplay(999);
      expect(formatted).toBeUndefined();
    });
  });

  describe('edge cases', () => {
    it('should handle empty translation list', () => {
      const emptyManager = new QuizManager([]);
      const question = emptyManager.getNextQuestion();
      expect(question.question).toBeNull();
    });

    it('should throw error for invalid translation ID in submitAnswer', () => {
      expect(() => {
        quizManager.submitAnswer(999, 'answer');
      }).toThrow('Translation or progress not found');
    });

    it('should handle response time tracking', () => {
      const question = quizManager.getNextQuestion().question!;

      // Wait a bit to ensure response time is measurable
      setTimeout(() => {
        const result = quizManager.submitAnswer(question.translationId, '–ø—Ä–∏–≤–µ—Ç');
        expect(result.responseTimeMs).toBeDefined();
        expect(result.responseTimeMs).toBeGreaterThan(0);
      }, 10);
    });
  });
});
