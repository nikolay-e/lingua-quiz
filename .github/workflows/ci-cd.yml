name: CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

jobs:
  build:
    runs-on: ubuntu-latest
    # Add permissions to write to GHCR
    permissions:
      contents: read
      packages: write # Grant permission to push to GitHub Packages (GHCR)

    strategy:
      matrix:
        service: [backend, frontend, integration-e2e-tests]

    steps:
      - name: Checkout code
        uses: actions/checkout@v5.0.0

      # Setup Docker Buildx
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3.11.1

      # Login to GitHub Container Registry (GHCR)
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }} # Use GITHUB_TOKEN for secure auth

      # Build and push image with cache
      - name: Build and push ${{ matrix.service }} image
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          target: ${{ matrix.service }}
          push: true
          tags: ghcr.io/${{ github.repository }}/lingua-quiz-${{ matrix.service }}:${{ github.event.pull_request.head.sha || github.sha }}
          # Cache strategy: Use main branch cache as primary source for consistent builds
          cache-from: |
            type=registry,ref=ghcr.io/${{ github.repository }}/lingua-quiz-${{ matrix.service }}:cache-main
          cache-to: |
            type=registry,ref=ghcr.io/${{ github.repository }}/lingua-quiz-${{ matrix.service }}:cache-${{ github.ref_name == 'refs/heads/main' && 'main' || 'pr' }},mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    permissions:
      contents: read
    env:
      CI: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v5.0.0

      # Setup Helm
      - name: Setup Helm
        uses: azure/setup-helm@v4.3.1
        with:
          version: 'v3.15.4' # Pin to specific version

      # Setup kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v4.0.1
        with:
          version: 'v1.30.0' # Pin to specific version

      # Setup SOPS
      - name: Setup SOPS
        uses: mdgreenwald/mozilla-sops-action@v1.6.0
        with:
          version: '3.10.2' # Pin to specific version

      # Set environment name for deployment (production for main, staging for PRs)
      - name: Set deployment environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "env_name=staging" >> $GITHUB_OUTPUT
            echo "namespace=lingua-quiz-staging" >> $GITHUB_OUTPUT
          else
            echo "env_name=prod" >> $GITHUB_OUTPUT
            echo "namespace=lingua-quiz-production" >> $GITHUB_OUTPUT
          fi

      # Configure kubeconfig
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          cat << 'EOF' > $HOME/.kube/config
          ${{ secrets.KUBE_CONFIG }}
          EOF
          chmod 600 $HOME/.kube/config

      # Setup SOPS with age key
      - name: Setup SOPS with age key
        run: |
          echo "${{ secrets.AGE_PRIVATE_KEY }}" > .age-key.txt
          chmod 600 .age-key.txt

      # Create GHCR secret in target namespace
      - name: Create GHCR secret
        run: |
          NAMESPACE="${{ steps.env.outputs.namespace }}"
          echo "Creating GHCR secret in namespace: $NAMESPACE"

          # Create namespace if it doesn't exist
          kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

          # Delete existing secret if it exists (to update credentials)
          kubectl delete secret ghcr-secret -n "$NAMESPACE" || true

          # Create new GHCR secret
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.repository_owner }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=noreply@github.com \
            -n "$NAMESPACE"

      # Deploy with Makefile, now using GHCR images
      - name: Deploy with Makefile
        id: helm-deploy
        run: |
          IMAGE_TAG="${{ github.event.pull_request.head.sha || github.sha }}"
          ENV_NAME="${{ steps.env.outputs.env_name }}"

          echo "Deploying to $ENV_NAME environment with image tag: $IMAGE_TAG"

          # Debug: Show current releases
          echo "Listing all Helm releases:"
          helm list -A || true

          # Validate chart before installation
          echo "Validating Helm chart..."
          helm lint ./helm/lingua-quiz-app

          # Deploy using Makefile with GHCR registry (no clean to avoid downtime)
          echo "Deploying to $ENV_NAME..."
          make deploy ENV=$ENV_NAME IMAGE_TAG="$IMAGE_TAG" REGISTRY="ghcr.io/${{ github.repository }}"

      # Wait for test jobs to complete and check their status
      - name: Wait for and validate test jobs
        if: steps.env.outputs.env_name == 'staging'
        run: |
          NAMESPACE="${{ steps.env.outputs.namespace }}"
          echo "Waiting for test jobs to complete in namespace: $NAMESPACE"

          # Wait for test job to complete using kubectl wait
          echo "Waiting for test job to complete..."
          kubectl wait --for=condition=complete job/lingua-quiz-tests -n "$NAMESPACE" --timeout=15m || {
            echo "‚ùå Test job failed or timed out"
            kubectl describe job lingua-quiz-tests -n "$NAMESPACE"
            kubectl logs job/lingua-quiz-tests -n "$NAMESPACE" --all-containers --tail=100 || true
            exit 1
          }

          echo "‚úÖ Test job completed successfully"
          kubectl logs job/lingua-quiz-tests -n "$NAMESPACE" --all-containers --tail=50

      # Post-deployment verification for production
      - name: Production deployment verification
        if: steps.env.outputs.env_name == 'prod'
        run: |
          echo "üîç Performing post-deployment verification for production..."

          # Wait a moment for services to be ready
          sleep 30

          # Health check for backend API
          BACKEND_URL="https://lingua-quiz.nikolay-eremeev.com/api/health"
          echo "Checking backend health at: $BACKEND_URL"
          for i in {1..5}; do
            if curl -f -s --max-time 10 "$BACKEND_URL" > /dev/null; then
              echo "‚úÖ Backend health check passed"
              break
            else
              echo "‚ö†Ô∏è Backend health check failed (attempt $i/5)"
              if [ $i -eq 5 ]; then
                echo "‚ùå Backend health check failed after 5 attempts"
                exit 1
              fi
              sleep 10
            fi
          done

          # Health check for frontend
          FRONTEND_URL="https://lingua-quiz.nikolay-eremeev.com"
          echo "Checking frontend at: $FRONTEND_URL"
          for i in {1..5}; do
            if curl -f -s --max-time 10 "$FRONTEND_URL" > /dev/null; then
              echo "‚úÖ Frontend health check passed"
              break
            else
              echo "‚ö†Ô∏è Frontend health check failed (attempt $i/5)"
              if [ $i -eq 5 ]; then
                echo "‚ùå Frontend health check failed after 5 attempts"
                exit 1
              fi
              sleep 10
            fi
          done

          echo "‚úÖ Production deployment verification completed successfully"
