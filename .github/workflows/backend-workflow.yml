name: Backend Workflow

on:
  workflow_call:
    secrets:
      # Docker & K8s
      DOCKER_REGISTRY_USERNAME:
        required: true
      DOCKER_REGISTRY_TOKEN:
        required: true
      KUBE_CONFIG:
        required: true
      # App Secrets
      JWT_SECRET:
        required: true
      POSTGRES_DB:
        required: true
      POSTGRES_USER:
        required: true
      POSTGRES_PASSWORD:
        required: true
      # VPS & Nginx Secrets
      VPS_HOST:
        required: true
      VPS_USER:
        required: true
      VPS_SSH_PRIVATE_KEY:
        required: true
      SSL_CERT:
        required: true
      SSL_KEY:
        required: true

permissions:
  contents: read

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ env.IMAGE_TAG }}
      deploy_env: ${{ env.DEPLOY_ENV }}
    steps:
      - uses: actions/checkout@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_TOKEN }}
      - name: Set environment variables
        run: |
          echo "DEPLOY_ENV=$([[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]] && echo "production" || echo "test")" >> $GITHUB_ENV
          SAFE_REF_NAME=$(echo "${{ github.head_ref || github.ref_name }}" | sed -e 's/[^a-zA-Z0-9.-]/-/g' | cut -c1-128)
          echo "IMAGE_TAG=${SAFE_REF_NAME}-${{ github.run_number }}" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ secrets.DOCKER_REGISTRY_USERNAME }}/lingua-quiz-backend" >> $GITHUB_ENV
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "LATEST_TAG=latest" >> $GITHUB_ENV
          fi
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./packages/backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            ${{ env.LATEST_TAG != '' && format('{0}:{1}', env.IMAGE_NAME, env.LATEST_TAG) || '' }}
      - name: Log build details
        run: |
          echo "::group::Build Details"
          echo "Deploy Environment: ${{ env.DEPLOY_ENV }}"
          echo "Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          [[ -n "${{ env.LATEST_TAG }}" ]] && echo "Latest Tag Added: ${{ env.IMAGE_NAME }}:latest"
          echo "::endgroup::"

  deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    environment: ${{ needs.build-and-push.outputs.deploy_env }}
    steps:
      - uses: actions/checkout@v3

      - name: Setup Kubernetes Tools
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  | bash
          sudo mv kustomize /usr/local/bin/
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Set up kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Verify kubectl configuration
        run: |
          kubectl cluster-info

      - name: Set deployment environment variables
        env:
          DEPLOY_ENV_FROM_BUILD: ${{ needs.build-and-push.outputs.deploy_env }}
          IMAGE_TAG_FROM_BUILD: ${{ needs.build-and-push.outputs.image_tag }}
        run: |
          echo "DEPLOY_ENV=${DEPLOY_ENV_FROM_BUILD}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${IMAGE_TAG_FROM_BUILD}" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ secrets.DOCKER_REGISTRY_USERNAME }}/lingua-quiz-backend" >> $GITHUB_ENV
          if [[ "$DEPLOY_ENV_FROM_BUILD" == "production" ]]; then
            echo "DEPLOY_NAMESPACE=default" >> $GITHUB_ENV
            echo "DEPLOY_PORT=9000" >> $GITHUB_ENV
            echo "API_HOST=api-lingua-quiz.nikolay-eremeev.com" >> $GITHUB_ENV
          else # test environment
            echo "DEPLOY_NAMESPACE=test" >> $GITHUB_ENV
            echo "DEPLOY_PORT=9001" >> $GITHUB_ENV
            echo "API_HOST=test-api-lingua-quiz.nikolay-eremeev.com" >> $GITHUB_ENV
          fi
          echo "SSL_CERT_PATH=/etc/nginx/ssl/${API_HOST}.crt" >> $GITHUB_ENV
          echo "SSL_KEY_PATH=/etc/nginx/ssl/${API_HOST}.key" >> $GITHUB_ENV

      - name: Clean up Previous Production App Deployment (if exists)
        if: env.DEPLOY_NAMESPACE == 'default'
        run: |
          echo "Cleaning up Production App resources in namespace: ${{ env.DEPLOY_NAMESPACE }}"
          kubectl delete deployment lingua-quiz -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete service lingua-quiz-service -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete secret jwt-secret -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          echo "Waiting a few seconds..."
          sleep 5

      - name: Clean up Previous Test Deployment (if exists)
        if: env.DEPLOY_NAMESPACE == 'test'
        run: |
          echo "Cleaning up Test resources in namespace: ${{ env.DEPLOY_NAMESPACE }}"
          kubectl delete deployment lingua-quiz -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete service lingua-quiz-service -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete secret jwt-secret -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete statefulset postgres -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=60s # StatefulSet может удаляться дольше
          kubectl delete service postgres -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete secret postgres-secret -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=30s
          kubectl delete pvc -l app=postgres -n ${{ env.DEPLOY_NAMESPACE }} --ignore-not-found=true --timeout=60s # PVC тоже может удаляться дольше
          echo "Waiting a few seconds for resources to terminate..."
          sleep 10

      - name: Create Kubernetes Resources (Namespace & Secrets)
        run: |
          kubectl create namespace ${{ env.DEPLOY_NAMESPACE }} --dry-run=client -o yaml | kubectl apply --namespace ${{ env.DEPLOY_NAMESPACE }} -f -
          kubectl create secret generic jwt-secret \
            --namespace ${{ env.DEPLOY_NAMESPACE }} \
            --from-literal=JWT_SECRET=${{ secrets.JWT_SECRET }} \
            --dry-run=client -o yaml | kubectl apply --namespace ${{ env.DEPLOY_NAMESPACE }} -f -
          kubectl create secret generic postgres-secret \
            --namespace=${{ env.DEPLOY_NAMESPACE }} \
            --from-literal=POSTGRES_DB=${{ secrets.POSTGRES_DB }} \
            --from-literal=POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
            --from-literal=POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            --dry-run=client -o yaml | kubectl apply --namespace ${{ env.DEPLOY_NAMESPACE }} -f -

      - name: Update Kubernetes Manifests
        env:
          K8S_DIR: ./packages/backend/k8s
        run: |
          cd ${K8S_DIR}
          echo "Updating kustomization with image=${IMAGE_NAME}:${IMAGE_TAG}, namespace=${DEPLOY_NAMESPACE}"
          yq e ".images[0].newName = \"${IMAGE_NAME}\"" -i kustomization.yaml
          yq e ".images[0].newTag = \"${{ env.IMAGE_TAG }}\"" -i kustomization.yaml
          yq e ".namespace = \"${{ env.DEPLOY_NAMESPACE }}\"" -i kustomization.yaml
          echo "Updating deployment.yaml with port=${DEPLOY_PORT}"
          yq e "(.spec.template.spec.containers[0].ports[0].containerPort) = ${{ env.DEPLOY_PORT }}" -i deployment.yaml
          yq e "(.spec.template.spec.containers[0].ports[0].hostPort) = ${{ env.DEPLOY_PORT }}" -i deployment.yaml
          yq e "(.spec.template.spec.containers[0].livenessProbe.httpGet.port) = ${{ env.DEPLOY_PORT }}" -i deployment.yaml
          yq e "(.spec.template.spec.containers[0].readinessProbe.httpGet.port) = ${{ env.DEPLOY_PORT }}" -i deployment.yaml
          yq e "(.spec.template.spec.containers[0].startupProbe.httpGet.port) = ${{ env.DEPLOY_PORT }}" -i deployment.yaml
          yq e "(.spec.template.spec.containers[0].env[] | select(.name == \"PORT\")).value = strenv(DEPLOY_PORT)" -i deployment.yaml
          echo "Updating service.yaml with port=${DEPLOY_PORT}"
          yq e "(.spec.ports[0].port) = ${{ env.DEPLOY_PORT }}" -i service.yaml
          yq e "(.spec.ports[0].targetPort) = ${{ env.DEPLOY_PORT }}" -i service.yaml

      - name: Deploy to Kubernetes
        env:
          K8S_DIR: ./packages/backend/k8s
        run: |
          cd ${K8S_DIR}
          echo "Applying Kubernetes manifests with kustomize..."
          kustomize build . | kubectl apply --namespace ${{ env.DEPLOY_NAMESPACE }} -f -

      - name: Wait for Deployments and Run Migrations
        run: |
          echo "Waiting for Kubernetes deployments in namespace: ${{ env.DEPLOY_NAMESPACE }}..."
          kubectl rollout status statefulset/postgres -n ${{ env.DEPLOY_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/lingua-quiz -n ${{ env.DEPLOY_NAMESPACE }} --timeout=300s
          echo "Deployments ready. Waiting a few seconds before migration..."
          sleep 10
          echo "Running database migrations..."
          BACKEND_POD=$(kubectl get pods -l app=lingua-quiz -n ${{ env.DEPLOY_NAMESPACE }} -o jsonpath="{.items[0].metadata.name}" 2>/dev/null)
          if [[ -z "$BACKEND_POD" ]]; then
             echo "::error::Could not find backend pod to run migrations."
             exit 1
          fi
          echo "Found backend pod: $BACKEND_POD"
          DB_NAME=$(kubectl get secret postgres-secret -n ${{ env.DEPLOY_NAMESPACE }} -o jsonpath="{.data.POSTGRES_DB}" | base64 --decode)
          DB_USER=$(kubectl get secret postgres-secret -n ${{ env.DEPLOY_NAMESPACE }} -o jsonpath="{.data.POSTGRES_USER}" | base64 --decode)
          DB_PASS=$(kubectl get secret postgres-secret -n ${{ env.DEPLOY_NAMESPACE }} -o jsonpath="{.data.POSTGRES_PASSWORD}" | base64 --decode)
          kubectl exec $BACKEND_POD -n ${{ env.DEPLOY_NAMESPACE }} -- \
            sh -c "DB_HOST=postgres DB_PORT=5432 POSTGRES_DB=$DB_NAME POSTGRES_USER=$DB_USER POSTGRES_PASSWORD=$DB_PASS npm run migrate"
          echo "Migrations command executed."

      - name: Configure Nginx on VPS
        uses: appleboy/ssh-action@v1.0.3
        env:
          API_HOST_ENV: ${{ env.API_HOST }}
          DEPLOY_PORT_ENV: ${{ env.DEPLOY_PORT }}
          SSL_CERT_PATH_ENV: ${{ env.SSL_CERT_PATH }}
          SSL_KEY_PATH_ENV: ${{ env.SSL_KEY_PATH }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          envs: API_HOST_ENV, DEPLOY_PORT_ENV, SSL_CERT_PATH_ENV, SSL_KEY_PATH_ENV
          script: |
            echo "Configuring Nginx for ${API_HOST_ENV} proxying to ${DEPLOY_PORT_ENV}"
            sudo mkdir -p /etc/nginx/ssl
            sudo chmod 700 /etc/nginx/ssl
            echo "Writing SSL certificate to ${SSL_CERT_PATH_ENV}"
            echo "${{ secrets.SSL_CERT }}" | sudo tee "${SSL_CERT_PATH_ENV}" > /dev/null
            echo "Writing SSL key to ${SSL_KEY_PATH_ENV}"
            echo "${{ secrets.SSL_KEY }}" | sudo tee "${SSL_KEY_PATH_ENV}" > /dev/null
            echo "Setting permissions for SSL key"
            sudo chmod 600 "${SSL_KEY_PATH_ENV}"
            NGINX_CONF_PATH="/etc/nginx/sites-available/${API_HOST_ENV}.conf"
            echo "Creating Nginx config at ${NGINX_CONF_PATH}"
            cat <<EOF | sudo tee "${NGINX_CONF_PATH}" > /dev/null
            server {
                listen 443 ssl http2;
                listen [::]:443 ssl http2;
                server_name ${API_HOST_ENV};

                ssl_certificate ${SSL_CERT_PATH_ENV};
                ssl_certificate_key ${SSL_KEY_PATH_ENV};

                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_prefer_server_ciphers off;
                ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
                ssl_session_cache shared:SSL:10m;
                ssl_session_timeout 1d;
                ssl_session_tickets off;

                access_log /var/log/nginx/${API_HOST_ENV}.access.log;
                error_log /var/log/nginx/${API_HOST_ENV}.error.log;

                location / {
                    proxy_pass http://127.0.0.1:${DEPLOY_PORT_ENV};
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_set_header X-Forwarded-Host \$host;
                    proxy_set_header X-Forwarded-Port \$server_port;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                }
            }
            EOF
            echo "Enabling Nginx site"
            sudo ln -sf "${NGINX_CONF_PATH}" "/etc/nginx/sites-enabled/"
            echo "Testing Nginx configuration"
            if sudo nginx -t; then
              echo "Reloading Nginx"
              sudo systemctl reload nginx
            else
              echo "::error::Nginx configuration test failed! Check the Nginx error log on the server."
              exit 1
            fi
            echo "Nginx configuration for ${API_HOST_ENV} updated successfully."

      - name: Log deployment status
        run: |
          echo "::group::Deployment Status"
          echo "Deploy Environment: ${{ env.DEPLOY_ENV }}"
          echo "Namespace: ${{ env.DEPLOY_NAMESPACE }}"
          echo "Target Port (hostPort/containerPort): ${{ env.DEPLOY_PORT }}"
          echo "API Host (Nginx Server Name): ${{ env.API_HOST }}"
          echo "Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "Deployment to Kubernetes completed."
          echo "Nginx configuration on VPS updated."
          echo "::endgroup::"

  test:
    needs: [deploy]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"
      - name: Install dependencies
        run: npm ci
      - name: Set environment variables for tests
        env:
          DEPLOY_ENV_FROM_BUILD: ${{ needs.build-and-push.outputs.deploy_env }}
        run: |
          echo "NODE_ENV=test" >> $GITHUB_ENV
          if [[ "$DEPLOY_ENV_FROM_BUILD" == "production" ]]; then
            echo "API_URL=https://api-lingua-quiz.nikolay-eremeev.com" >> $GITHUB_ENV
          else
            echo "API_URL=https://test-api-lingua-quiz.nikolay-eremeev.com" >> $GITHUB_ENV
          fi
      - name: Run backend tests
        env:
          API_URL: ${{ env.API_URL }}
        run: |
          echo "Running tests against URL: ${API_URL}"
          npm run test --workspace=@linguaquiz/backend
          echo "::group::Test Results"
          echo "Tests completed. Check test runner output above for details."
          echo "::endgroup::"
